---
title: "MRLocus - estimation of gene-to-trait effects"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
author: "Anqi Zhu, Nana Matoba, Jason Stein, Michael Love"
output: 
  rmarkdown::html_document:
    self_contained: false
    highlight: pygments
abstract: |
  MRLocus provides estimation of gene-to-trait effects from eQTL and
  GWAS summary statistics, for loci with allelic heterogeneity:
  multiple LD-independent signal clusters representing distinct
  eQTLs. Evidence is aggregated across signal clusters for mediation
  of the downstream GWAS trait through the gene.
  MRLocus package version: `r packageVersion("mrlocus")`
bibliography: library.bib
vignette: |
  %\VignetteIndexEntry{MRLocus - estimation of gene-to-trait effects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(cache=FALSE, message=FALSE, warning=FALSE)
```

# Introduction

MRLocus provides Bayesian analysis of gene-to-trait mediation effects,
making use of the Stan and RStan software packages for inference
[@stan;@rstan].

The authors of the associated [MRLocus manuscript](https://doi.org/10.1101/2020.08.14.250720)
[@mrlocus] is:

> Anqi Zhu\*, Nana Matoba\*, Emmaleigh Wilson, Amanda L.Tapia,
> Yun Li, Joseph G. Ibrahim, Jason L. Stein, Michael I. Love

\* Both authors contributed equally to this work.

In this vignette we demonstrate use of MRLocus on simulated summary
statistics. The simulated data in this vignette does not include
the steps of importing summary statistics and LD matrices from
external files. For that, we recommend looking at the R code we used
for analysis of the 
[public datasets](https://github.com/mikelove/mrlocusPaper/blob/master/public/analysis.R)
in the manuscript. 

Briefly, two important helper functions for import and preprocessing
that are provided in this package are `collapseHighCorSNPs` and
`flipAllelesAndGather`, for importing summary statistics across
LD-independent signal clusters (sets of SNPs that are non-overlapping
and have low correlation in a reference population). We use the phrase
"LD-independent signal cluster" as in the PTWAS software and paper
[@ptwas].

It is strongly recommended to use these two functions for data import,
in particular as the first function will reduce the number of SNPs per
cluster and help deal with identifiability issues during the Bayesian
colocalization step. As described in the manuscript, MRLocus does not
attempt to resolve putative causal SNPs among sets of SNPs with
correlation $> 0.95$, but instead it collapses this redundancy using
`collapseHighCorSNPs`. The second function ensures that the alleles
are flipped properly across eQTL and GWAS datasets (the function will
handle this to avoid manual processing by the user), such that the
alleles are coded in such a way that the downstream statistical
modeling functions will expect. The second function ensures that both
studies refer to the same allele, which is the expression-increasing
allele for an index SNP within each LD-independent signal cluster.

We recommend using PLINK [@plink] for generation of signal clusters
(see Methods section of MRLocus manuscript). 

We have not yet implemented, but plan on providing an import function
from the [TwoSampleMR](https://github.com/MRCIEU/TwoSampleMR) package.

# Simulated input data

The following simulated summary statistics are generated from a
multivariate normal distribution, similar to the model used in
eCAVIAR [@eCAVIAR]. In contrast, the simulations in the MRLocus
manuscript make use of
the [twas_sim](https://github.com/mancusolab/twas_sim) framework 
[@twassim].

```{r}
library(mrlocus)
set.seed(1)
out <- makeSimDataForMrlocus()
```

This simulated data consists of a list of lists. The elements are: 
`beta_hat_a`, `beta_hat_b`, `se_a`, `se_b`, `Sigma_a`, `Sigma_b`, and
`alleles`, which provide the estimated coefficients, standard errors
(SE), and LD matrices for the two studies, A and B (typically, eQTL and
GWAS), as well as a data.frame with allele information (SNP ID,
reference allele, and effect allele).
The LD matrices can be identical if distinct matrices for each study
are not available. Each element itself should be a list of
vectors/matrices/data.frames across LD-independent signal clusters.

We can make a simple plot of the `beta_hat`'s, estimated coefficients
from A and B. The coefficients are numbered by the SNP order within
each signal cluster.

```{r initests, fig.height=7}
plotInitEstimates(out)
```

# Colocalization step

The first step in MRLocus is to perform colocalization of the
studies. To do so, we loop over the signal clusters, and store the
fitted models in a list called `fit`.

```{r}
fit <- list()
nsnp <- lengths(out$beta_hat_a)
nclust <- length(nsnp)
```

The following code chunk loops over signal clusters:

```{r}
options(mc.cores=2)
for (j in 1:nclust) {
  suppressWarnings({
    fit[[j]] <- fitBetaColoc(nsnp=nsnp[j],
                             beta_hat_a=out$beta_hat_a[[j]],
                             beta_hat_b=out$beta_hat_b[[j]],
                             se_a=out$se_a[[j]],
                             se_b=out$se_b[[j]],
                             Sigma_a=out$Sigma_a[[j]],
                             Sigma_b=out$Sigma_b[[j]])
  })
}
```

We now create a list containing the posterior mean from the
colocalization step, and the original SE values. Note the SE values
are now referred to as `sd`.

```{r}
res <- list(beta_hat_a=lapply(fit, `[[`, "beta_hat_a"),
            beta_hat_b=lapply(fit, `[[`, "beta_hat_b"),
            sd_a=out$se_a,
            sd_b=out$se_b,
            alleles=out$alleles)
```

# Slope fitting step

The following function extracts one SNP per signal cluster with the
largest posterior mean for the coefficient for study A
(e.g. eQTL). The selected SNPs and their posterior mean values are
plotted on the right panel in blue. We note that it is also possible
to perform EM-based clustering [@mclust] to extract more than one SNP
per signal cluster, through use of the `niter` argument, although this
was not evaluated in the MRLocus manuscript.

```{r extract}
res <- extractForSlope(res, plot=TRUE)
```

Now we are ready to fit the slope. In our testing we have used 10,000
iterations, though fewer may be sufficient. This step is typically
much faster than the colocalization step.

```{r}
res <- fitSlope(res, iter=10000)
```

# Examine MRLocus estimates

One of the elements in the results list `res` is the `stanfit` object,
which can be explored with functions from the `rstan` package.

The posterior mean for the gene-to-trait slope, alpha, is near the
simulated value of 0.5. The posterior mean for the dispersion around
the slope, sigma, is also estimated. Note that the estimate for sigma
has a large 80% credible interval, as we only have 4 signal clusters
over which to estimate dispersion.

```{r}
suppressPackageStartupMessages(library(rstan))
print(res$stanfit, pars=c("alpha","sigma"), probs=c(.1,.9), digits=3)
```

MRLocus provides a plot that summarizes the estimation of the
gene-to-trait effect. The estimated slope and an 80% credible interval
are indicated with a solid blue line and dashed blue lines,
respectively. The black points and error bars represent the posterior
mean for top SNPs from colocalization and the original SE.
An 80% band in light blue indicates a region that is
expected to contain 80% of the eQTL-GWAS pairs across signal
clusters, so reflecting the allelic heterogeneity. If the estimate of
$\sigma$ is of comparable size to $\alpha$ times typical eQTL effect
sizes (slope $\times$ location of black points on the x-axis), this
indicates a high degree of heterogeneity.

```{r mrlocus, fig.height=7}
plotMrlocus(res, main="MRLocus gene-to-trait effect estimate")
```

# Session info

```{r}
sessionInfo()
```

# References
